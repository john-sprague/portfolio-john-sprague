# CRDTs (Conflict-Free Replicated Data Types) 
CRDTs (Conflict-Free Replicated Data Types) are data structures designed for distributed systems that ensure eventual consistency without requiring complex synchronization mechanisms like locks or consensus protocols. They are particularly useful when multiple nodes update shared data independently.

### 🔥 **The 20% of CRDT Concepts That Deliver 80% of the Results**
1. **Eventual Consistency** – CRDTs ensure all replicas reach the same state without coordination.
2. **Types of CRDTs**:
   - **State-based (Convergent Replicated Data Type, CvRDT)** – Merge full state.
   - **Operation-based (Commutative Replicated Data Type, CmRDT)** – Merge only updates.
3. **Monotonicity** – Updates always grow in a way that prevents conflicts.
4. **Idempotency** – Applying the same update multiple times results in the same state.
5. **Commutativity** – Order of operations doesn’t matter.
6. **Merging Logic** – Each CRDT has a defined way to merge changes deterministically.

## 🏗️ **Building a Distributed Counter with CRDTs**
A counter is a simple but powerful use case for CRDTs, such as a **G-Counter (Grow-only Counter)** or **PN-Counter (Positive-Negative Counter).** 

### 🔹 **1. Choose the Right CRDT**
For a distributed counter:
- **G-Counter**: Supports only **increments** (e.g., likes on a post).
- **PN-Counter**: Supports **increments and decrements** (e.g., upvotes/downvotes).

### 🔹 **2. Implement a G-Counter**
A **G-Counter** maintains a per-node count and merges by taking the max value from each node.

#### **📌 Basic Steps:**
1. **Each node keeps its own local count.**
2. **When updating, it increments only its own count.**
3. **When merging, it takes the max value for each node.**

#### **🚀 G-Counter Implementation in Python**
```javascript
class GCounter {
    constructor(nodeId) {
        this.nodeId = nodeId; // Unique identifier for the node
        this.counts = {}; // Stores per-node counts
    }

    // Increment the counter for the current node
    increment(amount = 1) {
        if (!this.counts[this.nodeId]) {
            this.counts[this.nodeId] = 0;
        }
        this.counts[this.nodeId] += amount;
    }

    // Merge another GCounter into this one
    merge(otherCounter) {
        for (const [node, value] of Object.entries(otherCounter.counts)) {
            if (this.counts[node]) {
                this.counts[node] = Math.max(this.counts[node], value);
            } else {
                this.counts[node] = value;
            }
        }
    }

    // Get the total value of the counter
    value() {
        return Object.values(this.counts).reduce((sum, val) => sum + val, 0);
    }
}

// Example usage:
const node1 = new GCounter("A");
const node2 = new GCounter("B");

node1.increment(3); // Node A increments by 3
node2.increment(2); // Node B increments by 2

// Nodes sync (merge)
node1.merge(node2);
node2.merge(node1);

console.log(node1.value()); // Output: 5
console.log(node2.value()); // Output: 5
```

### 🔹 **3. Implement a PN-Counter**
A **PN-Counter** consists of two G-Counters:  
- **One for increments (P)**  
- **One for decrements (N)**  

The final value is `P - N`.

#### **🚀 PN-Counter Implementation**
```javascript
class PNCounter {
    constructor(nodeId) {
        this.nodeId = nodeId;
        this.positive = new GCounter(nodeId);
        this.negative = new GCounter(nodeId);
    }

    increment(amount = 1) {
        this.positive.increment(amount);
    }

    decrement(amount = 1) {
        this.negative.increment(amount);
    }

    merge(otherCounter) {
        this.positive.merge(otherCounter.positive);
        this.negative.merge(otherCounter.negative);
    }

    value() {
        return this.positive.value() - this.negative.value();
    }
}

// Example usage:
const node1 = new PNCounter("A");
const node2 = new PNCounter("B");

node1.increment(5);
node2.increment(3);
node1.decrement(2);

// Merge the two nodes
node1.merge(node2);
node2.merge(node1);

console.log(node1.value()); // Output: 6 (5 + 3 - 2)
console.log(node2.value()); // Output: 6
```

---

## 📡 **Integrating into a Distributed System**
Now that we have a CRDT counter, here’s how to use it in a real-world system:

### 🔹 **1. Use CRDTs in a Distributed Database**
Many databases like **Riak, Redis (CRDT module), and AntidoteDB** support CRDTs natively.

### 🔹 **2. Sync Updates Efficiently**
- **Peer-to-peer (Gossip Protocol)**: Nodes periodically exchange updates.
- **Event Sourcing**: Store operations in a log, replay them to reconstruct state.
- **Pub/Sub Model**: Use Kafka or RabbitMQ to broadcast updates.

- **Peer-to-Peer (Gossip Protocol) replication across CRDT replicas**
The internal implementation of CRDT is independent of the underlying network layer. For example, the communication layer can use gossip protocol for an efficient replication across CRDT replicas. The CRDT replication exchanges not only the data but also the operations performed on the data including their ordering and causality. The merging technique in CRDT will execute the received operations on the data. The following are the benefits of using CRDT to build the distributed counter.

offers local latency on read and write operations through multi-leader replication
enables automatic and deterministic conflict resolution
tolerant to network partitions
allow concurrent count updates without coordination between replica nodes
achieves eventual consistency through asynchronous data updates

### 🔹 **3. Handle Network Partitions Gracefully**
CRDTs guarantee **eventual consistency**, meaning updates will propagate and merge automatically once network partitions heal.

---

## 🚀 **Key Takeaways**
✅ **CRDTs eliminate conflicts in distributed systems.**  
✅ **G-Counter for increments; PN-Counter for inc/dec.**  
✅ **Use "merge by max" logic to ensure convergence.**  
✅ **Ideal for counters, collaborative docs, and shopping carts.**  
✅ **Integrate via gossip, event sourcing, or pub/sub for real-world use.**  

Want to go deeper? Try **Delta CRDTs** for efficiency or explore **LWW-Registers (Last Write Wins) for timestamped values.**

![alt text](image.png)

# **Detailed Breakdown of SQL Normalization Levels**  

**Normalization** is the process of organizing a database to reduce redundancy and improve data integrity. It involves dividing a database into smaller, more manageable tables and defining relationships between them.  

Here’s a simple breakdown of each **normal form (NF):**  

#### **First Normal Form (1NF) – Atomicity**  
✅ Each column contains only atomic (indivisible) values.  
✅ No repeating groups or arrays in a single row.  

**Example (Before 1NF - Bad Table Design)**  
| OrderID | Customer | Products Purchased  |  
|---------|---------|---------------------|  
| 101     | Alice   | Apples, Bananas     |  
| 102     | Bob     | Oranges, Apples     |  

**Problem:** The "Products Purchased" column has multiple values in a single cell.  

**After 1NF - Good Table Design**  
| OrderID | Customer | Product   |  
|---------|---------|---------|  
| 101     | Alice   | Apples   |  
| 101     | Alice   | Bananas  |  
| 102     | Bob     | Oranges  |  
| 102     | Bob     | Apples   |  

---

#### **Second Normal Form (2NF) – No Partial Dependencies**  
✅ 1NF is satisfied.  
✅ Every non-key column must depend on the whole primary key, not just part of it.  

**Example (Before 2NF - Bad Table Design)**  
| OrderID | Customer | Product  | Customer Address  |  
|---------|---------|---------|-----------------|  
| 101     | Alice   | Apples   | 123 Green St   |  
| 102     | Bob     | Oranges  | 456 Blue St    |  

**Problem:** The **Customer Address** only depends on "Customer" but not the whole "OrderID + Product" composite key.  

**After 2NF - Good Table Design (Splitting into Two Tables)**  
✅ **Orders Table**  
| OrderID | CustomerID | Product  |  
|---------|-----------|---------|  
| 101     | 1         | Apples  |  
| 102     | 2         | Oranges |  

✅ **Customers Table**  
| CustomerID | Customer Name | Address        |  
|-----------|--------------|--------------|  
| 1         | Alice        | 123 Green St  |  
| 2         | Bob          | 456 Blue St   |  

---

#### **Third Normal Form (3NF) – No Transitive Dependencies**  
✅ 2NF is satisfied.  
✅ No non-key column should depend on another non-key column.  

**Example (Before 3NF - Bad Table Design)**  
| OrderID | Product  | Supplier Name | Supplier Address  |  
|---------|---------|--------------|-----------------|  
| 101     | Apples  | Fresh Farms  | 789 Orchard Rd  |  
| 102     | Oranges | Citrus Co.   | 456 Orange St   |  

**Problem:** "Supplier Address" depends on "Supplier Name," not directly on "OrderID."  

**After 3NF - Good Table Design (Splitting into Two Tables)**  
✅ **Orders Table**  
| OrderID | Product  | SupplierID |  
|---------|---------|-----------|  
| 101     | Apples  | 1         |  
| 102     | Oranges | 2         |  

✅ **Suppliers Table**  
| SupplierID | Supplier Name | Supplier Address  |  
|-----------|--------------|-----------------|  
| 1         | Fresh Farms  | 789 Orchard Rd  |  
| 2         | Citrus Co.   | 456 Orange St   |  

---

# **Detailed Breakdown of SQL Primary Keys & Foreign Keys**  

In relational databases, **Primary Keys (PK)** and **Foreign Keys (FK)** play a crucial role in maintaining data integrity and defining relationships between tables.  

---

## **🔑 Primary Key (PK)**
### **Definition**  
A **Primary Key** is a column (or a set of columns) that uniquely identifies each row in a table.  

### **Key Characteristics**  
✅ **Unique** – No two rows can have the same primary key value.  
✅ **Non-null** – A primary key cannot contain NULL values.  
✅ **Immutable** – Once assigned, primary key values should not change.  
✅ **Minimal** – It contains only the necessary columns to uniquely identify a row.  

### **Example**  
#### **Customers Table (With Primary Key)**  
| CustomerID (PK) | Name  | Email           |  
|----------------|-------|----------------|  
| 1             | Alice | alice@email.com |  
| 2             | Bob   | bob@email.com   |  

Here, `CustomerID` is the **Primary Key** because it uniquely identifies each customer.  

### **Composite Primary Key**  
A **Composite Primary Key** consists of **two or more columns** that together form a unique identifier.  

#### **Example: Order Details Table (With Composite PK)**  
| OrderID (PK) | ProductID (PK) | Quantity |  
|-------------|--------------|----------|  
| 101         | A1           | 2        |  
| 101         | B3           | 5        |  
| 102         | A1           | 3        |  

Here, the **combination** of `OrderID` and `ProductID` ensures uniqueness.

---

## **🔗 Foreign Key (FK)**
### **Definition**  
A **Foreign Key** is a column (or a set of columns) that **references a Primary Key** in another table. It establishes a relationship between tables, enforcing referential integrity.  

### **Key Characteristics**  
✅ **References a Primary Key** in another table.  
✅ **Maintains Data Integrity** – Prevents invalid data entry.  
✅ **Supports Relationships** – Enables One-to-Many or Many-to-Many relationships.  
✅ **Can Contain NULLs** if the relationship is optional.  

### **Example: Orders and Customers Relationship**  
#### **Customers Table (With Primary Key)**  
| CustomerID (PK) | Name  | Email           |  
|----------------|-------|----------------|  
| 1             | Alice | alice@email.com |  
| 2             | Bob   | bob@email.com   |  

#### **Orders Table (With Foreign Key)**  
| OrderID (PK) | CustomerID (FK) | OrderDate  |  
|-------------|----------------|-----------|  
| 101         | 1              | 2024-02-01 |  
| 102         | 2              | 2024-02-05 |  
| 103         | 1              | 2024-02-10 |  

Here, `CustomerID` in the **Orders Table** is a **Foreign Key**, linking to the `CustomerID` in the **Customers Table**.

---

## **🔗 Relationships Between Tables**
### **One-to-Many Relationship**  
- **Example:** One customer can place multiple orders.  
- **Implementation:** A **Foreign Key in the Orders Table** referencing the **Primary Key in the Customers Table**.  

### **Many-to-Many Relationship**  
- **Example:** Students can enroll in multiple courses, and each course can have multiple students.  
- **Implementation:** Use a **junction table** with Foreign Keys referencing both tables.  

#### **Example: Enrollment Table (Many-to-Many Relationship)**
| StudentID (FK) | CourseID (FK) | EnrollmentDate |  
|---------------|-------------|---------------|  
| 1            | 101         | 2024-01-15    |  
| 2            | 102         | 2024-01-16    |  
| 1            | 103         | 2024-01-17    |  

---

## **🔹 SQL Commands for Primary and Foreign Keys**
### **Creating a Table with a Primary Key**
```sql
CREATE TABLE Customers (
    CustomerID INT PRIMARY KEY,
    Name VARCHAR(100),
    Email VARCHAR(100) UNIQUE
);
```

### **Creating a Table with a Foreign Key**
```sql
CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    CustomerID INT,
    OrderDate DATE,
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);
```

### **Defining a Composite Primary Key**
```sql
CREATE TABLE OrderDetails (
    OrderID INT,
    ProductID INT,
    Quantity INT,
    PRIMARY KEY (OrderID, ProductID)
);