# CRDTs (Conflict-Free Replicated Data Types) 
CRDTs (Conflict-Free Replicated Data Types) are data structures designed for distributed systems that ensure eventual consistency without requiring complex synchronization mechanisms like locks or consensus protocols. They are particularly useful when multiple nodes update shared data independently.

### 🔥 **The 20% of CRDT Concepts That Deliver 80% of the Results**
1. **Eventual Consistency** – CRDTs ensure all replicas reach the same state without coordination.
2. **Types of CRDTs**:
   - **State-based (Convergent Replicated Data Type, CvRDT)** – Merge full state.
   - **Operation-based (Commutative Replicated Data Type, CmRDT)** – Merge only updates.
3. **Monotonicity** – Updates always grow in a way that prevents conflicts.
4. **Idempotency** – Applying the same update multiple times results in the same state.
5. **Commutativity** – Order of operations doesn’t matter.
6. **Merging Logic** – Each CRDT has a defined way to merge changes deterministically.

## 🏗️ **Building a Distributed Counter with CRDTs**
A counter is a simple but powerful use case for CRDTs, such as a **G-Counter (Grow-only Counter)** or **PN-Counter (Positive-Negative Counter).** 

### 🔹 **1. Choose the Right CRDT**
For a distributed counter:
- **G-Counter**: Supports only **increments** (e.g., likes on a post).
- **PN-Counter**: Supports **increments and decrements** (e.g., upvotes/downvotes).

### 🔹 **2. Implement a G-Counter**
A **G-Counter** maintains a per-node count and merges by taking the max value from each node.

#### **📌 Basic Steps:**
1. **Each node keeps its own local count.**
2. **When updating, it increments only its own count.**
3. **When merging, it takes the max value for each node.**

#### **🚀 G-Counter Implementation in Python**
```javascript
class GCounter {
    constructor(nodeId) {
        this.nodeId = nodeId; // Unique identifier for the node
        this.counts = {}; // Stores per-node counts
    }

    // Increment the counter for the current node
    increment(amount = 1) {
        if (!this.counts[this.nodeId]) {
            this.counts[this.nodeId] = 0;
        }
        this.counts[this.nodeId] += amount;
    }

    // Merge another GCounter into this one
    merge(otherCounter) {
        for (const [node, value] of Object.entries(otherCounter.counts)) {
            if (this.counts[node]) {
                this.counts[node] = Math.max(this.counts[node], value);
            } else {
                this.counts[node] = value;
            }
        }
    }

    // Get the total value of the counter
    value() {
        return Object.values(this.counts).reduce((sum, val) => sum + val, 0);
    }
}

// Example usage:
const node1 = new GCounter("A");
const node2 = new GCounter("B");

node1.increment(3); // Node A increments by 3
node2.increment(2); // Node B increments by 2

// Nodes sync (merge)
node1.merge(node2);
node2.merge(node1);

console.log(node1.value()); // Output: 5
console.log(node2.value()); // Output: 5
```

### 🔹 **3. Implement a PN-Counter**
A **PN-Counter** consists of two G-Counters:  
- **One for increments (P)**  
- **One for decrements (N)**  

The final value is `P - N`.

#### **🚀 PN-Counter Implementation**
```javascript
class PNCounter {
    constructor(nodeId) {
        this.nodeId = nodeId;
        this.positive = new GCounter(nodeId);
        this.negative = new GCounter(nodeId);
    }

    increment(amount = 1) {
        this.positive.increment(amount);
    }

    decrement(amount = 1) {
        this.negative.increment(amount);
    }

    merge(otherCounter) {
        this.positive.merge(otherCounter.positive);
        this.negative.merge(otherCounter.negative);
    }

    value() {
        return this.positive.value() - this.negative.value();
    }
}

// Example usage:
const node1 = new PNCounter("A");
const node2 = new PNCounter("B");

node1.increment(5);
node2.increment(3);
node1.decrement(2);

// Merge the two nodes
node1.merge(node2);
node2.merge(node1);

console.log(node1.value()); // Output: 6 (5 + 3 - 2)
console.log(node2.value()); // Output: 6
```

---

## 📡 **Integrating into a Distributed System**
Now that we have a CRDT counter, here’s how to use it in a real-world system:

### 🔹 **1. Use CRDTs in a Distributed Database**
Many databases like **Riak, Redis (CRDT module), and AntidoteDB** support CRDTs natively.

### 🔹 **2. Sync Updates Efficiently**
- **Peer-to-peer (Gossip Protocol)**: Nodes periodically exchange updates.
- **Event Sourcing**: Store operations in a log, replay them to reconstruct state.
- **Pub/Sub Model**: Use Kafka or RabbitMQ to broadcast updates.

- **Peer-to-Peer (Gossip Protocol) replication across CRDT replicas**
The internal implementation of CRDT is independent of the underlying network layer. For example, the communication layer can use gossip protocol for an efficient replication across CRDT replicas. The CRDT replication exchanges not only the data but also the operations performed on the data including their ordering and causality. The merging technique in CRDT will execute the received operations on the data. The following are the benefits of using CRDT to build the distributed counter.

offers local latency on read and write operations through multi-leader replication
enables automatic and deterministic conflict resolution
tolerant to network partitions
allow concurrent count updates without coordination between replica nodes
achieves eventual consistency through asynchronous data updates

### 🔹 **3. Handle Network Partitions Gracefully**
CRDTs guarantee **eventual consistency**, meaning updates will propagate and merge automatically once network partitions heal.

---

## 🚀 **Key Takeaways**
✅ **CRDTs eliminate conflicts in distributed systems.**  
✅ **G-Counter for increments; PN-Counter for inc/dec.**  
✅ **Use "merge by max" logic to ensure convergence.**  
✅ **Ideal for counters, collaborative docs, and shopping carts.**  
✅ **Integrate via gossip, event sourcing, or pub/sub for real-world use.**  

Want to go deeper? Try **Delta CRDTs** for efficiency or explore **LWW-Registers (Last Write Wins) for timestamped values.**

![alt text](image.png)